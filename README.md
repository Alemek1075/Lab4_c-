ЗВІТ З ЛАБОРАТОРНОЇ РОБОТИ
Тема: Синхронізація доступу до розділюваних ресурсів у багатопотокових програмах

Абзац 1: Інформація про виконавця
Виконав: студент групи К-27, Базилевич Олексій.

Абзац 2: Умова задачі (Варіант 16)
Розробити структуру даних, що складається з m=2 цілих полів.
Розподіл операцій для варіанту:
Поле 0: read - 20%, write - 5%
Поле 1: read - 20%, write - 5%
String (читання всієї структури): 50%
Загалом операції читання (read + string) складають 90%, а запису - лише 10%.

Абзац 3: Схема захисту даних та обґрунтування
Для захисту даних обрано схему Fine-Grained Locking (дрібномодульне блокування) з використанням Readers-Writer Lock.

Кількість та тип м'ютексів: Використано масив з двох м'ютексів типу std::shared_mutex (mutexes[0] та mutexes[1]) - по одному м'ютексу на кожне ціле поле даних.

Обґрунтування типу (shared_mutex): Оскільки у 16-му варіанті 90% операцій є читаючими (40% одиночні читання + 50% операція string), використання звичайного std::mutex призвело б до зайвої серіалізації. std::shared_mutex дозволяє кільком потокам одночасно захоплювати ресурс для читання (shared_lock), блокуючи його тільки для запису (unique_lock). Це критично для операції string, яка складає половину всіх запитів.

Обґрунтування кількості: Окремий м'ютекс на кожне поле дозволяє паралельно змінювати або читати різні поля. Наприклад, потік А може писати в Поле 0, поки потік Б читає Поле 1.

Уникнення взаємних блокувань (Deadlocks): Операція string потребує доступу до обох полів одночасно. Щоб уникнути deadlocks, захоплення м'ютексів завжди відбувається у фіксованому порядку: спочатку індекс 0, потім індекс 1.

Абзац 4: Результати вимірювань
Середній час виконання (у мілісекундах):

Файл variant_16.txt (90% reads):
1 потік: [Вписати число]
2 потоки: [Вписати число]
3 потоки: [Вписати число]

Файл equal.txt (Рівномірний):
1 потік: [Вписати число]
2 потоки: [Вписати число]
3 потоки: [Вписати число]

Файл skewed.txt (Багато записів):
1 потік: [Вписати число]
2 потоки: [Вписати число]
3 потоки: [Вписати число]

Абзац 5: Висновки
Результати вимірювань підтверджують ефективність обраної схеми захисту для заданого варіанту.
По-перше, для файлу variant_16.txt спостерігається прискорення при збільшенні кількості потоків. Це пояснюється високою часткою операцій читання (90%), які завдяки shared_mutex виконуються паралельно.
По-друге, операція отримання рядка (operator string) хоч і блокує обидва поля, але робить це у режимі shared, що не заважає іншим потокам читати ці ж поля.
По-третє, у сценарії skewed.txt (де штучно збільшена кількість записів) приріст продуктивності є меншим, оскільки операції запису вимагають ексклюзивного блокування (unique_lock), змушуючи потоки чекати один одного.

Абзац 6: Що зроблено самостійно

Розроблено клас ThreadSafeData без використання атомарних змінних, реалізовано методи get, set та перевантажено оператор приведення до рядка.

Реалізовано логіку захисту на базі std::shared_mutex з std::shared_lock для читання та std::unique_lock для запису.

Написано генератор тестових даних, що створює файли команд згідно з ймовірнісним розподілом 16-го варіанту.

Написано драйвер програми, який парсить текстові команди та виконує їх у заданій кількості потоків, вимірюючи час виконання за допомогою std::chrono.
