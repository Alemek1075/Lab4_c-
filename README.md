Звіт до лабораторної роботи №4

Виконавець: Базилевич Олексій, К-27

Умова задачі (Варіант 16): Розробити потокобезпечну структуру даних, що містить m цілих полів. Операції: читання поля, запис у поле, отримання рядкового представлення всієї структури. Для кожного поля задано відсоток операцій читання та запису, а також відсоток запитів на формування рядка (детальні параметри розподілу знаходяться у файлі variant_16.txt). Необхідно протестувати продуктивність при роботі з 1, 2 та 3 потоками для різних сценаріїв навантаження.
Схема захисту даних та обґрунтування: Для захисту даних використано підхід Fine-Grained Locking (дрібномодульне блокування). У структурі створено масив м'ютексів (std::mutex або std::shared_mutex), де кожен м'ютекс відповідає за одне конкретне ціле поле масиву даних.
    Операції read(index) та write(index, value) захоплюють лише м'ютекс, що відповідає індексу index. Це дозволяє іншим потокам одночасно працювати з іншими полями, не блокуючи один одного.
    Операція operator string() захоплює всі м'ютекси масиву одночасно. Щоб уникнути взаємного блокування (deadlock), захоплення м'ютексів завжди відбувається в одному і тому ж порядку (від індексу 0 до m-1). Обґрунтування: Використання одного глобального м'ютексу на всю структуру призвело б до послідовного виконання всіх операцій, що нівелює переваги багатопотоковості. Оскільки операції над різними полями є логічно незалежними, виділення окремого м'ютекса під кожне поле значно підвищує пропускну здатність програми при конкурентному доступі. Глобальне блокування застосовується лише для рідкісних операцій (отримання рядка), що вимагають миттєвого знімка стану всієї системи.
Результати виконання (час у мілісекундах):
Висновки: Результати тестування показують ефективність обраної схеми захисту. У сценарії "Згідно варіанту", де навантаження розподілене відповідно до очікувань (багато операцій з різними полями), спостерігається приріст продуктивності при збільшенні кількості потоків (час виконання зменшується). У сценарії з рівномірним розподілом результати також показують перевагу багатопотоковості, але можливе незначне зниження ефективності через частіші блокування, якщо запити випадково потрапляють на одні й ті самі поля. У "Конфліктному розподілі" (наприклад, коли всі потоки пишуть в одне поле або часто викликають string), час виконання може зростати або не змінюватися при збільшенні потоків через високу конкуренцію за м'ютекси (contention) та витрати на перемикання контексту. Таблиця підтверджує, що дрібномодульне блокування є ефективним для задач з високим рівнем незалежних операцій.
Що зроблено самостійно: Розроблено клас DataStructure з використанням контейнерів STL та засобів синхронізації. Реалізовано логіку блокування для окремих полів та алгоритм безпечного захоплення всіх м'ютексів для операції string. Написано допоміжний код для парсингу вхідних файлів у форматі write/read/string. Створено генератор тестових файлів, який формує послідовності команд згідно з заданими ймовірностями (для варіанту, рівномірний, конфліктний). Реалізовано заміри часу виконання за допомогою std::chrono.
