ЗВІТ З ЛАБОРАТОРНОЇ РОБОТИ
Тема: Синхронізація доступу до розділюваних ресурсів у багатопотокових програмах

Абзац 1: Інформація про виконавця
Виконав: студент групи К-27, Базилевич Олексій.

Абзац 2: Умова задачі (Варіант 16)
Розробити структуру даних, що складається з m=2 цілих полів.
Розподіл операцій для варіанту:
Поле 0: read - 20%, write - 5%
Поле 1: read - 20%, write - 5%
String (читання всієї структури): 50%
Загалом операції читання (read + string) складають 90%, а запису - лише 10%.

Абзац 3: Схема захисту даних та обґрунтування
Для захисту даних обрано схему Fine-Grained Locking (дрібномодульне блокування) з використанням Readers-Writer Lock.

Кількість та тип м'ютексів: Використано масив з двох м'ютексів типу std::shared_mutex (mutexes[0] та mutexes[1]) - по одному м'ютексу на кожне ціле поле даних.

Обґрунтування типу (shared_mutex): Оскільки у 16-му варіанті 90% операцій є читаючими (40% одиночні читання + 50% операція string), використання звичайного std::mutex призвело б до зайвої серіалізації. std::shared_mutex дозволяє кільком потокам одночасно захоплювати ресурс для читання (shared_lock), блокуючи його тільки для запису (unique_lock). Це критично для операції string, яка складає половину всіх запитів.

Обґрунтування кількості: Окремий м'ютекс на кожне поле дозволяє паралельно змінювати або читати різні поля. Наприклад, потік А може писати в Поле 0, поки потік Б читає Поле 1.

Уникнення взаємних блокувань (Deadlocks): Операція string потребує доступу до обох полів одночасно. Щоб уникнути deadlocks, захоплення м'ютексів завжди відбувається у фіксованому порядку: спочатку індекс 0, потім індекс 1.

